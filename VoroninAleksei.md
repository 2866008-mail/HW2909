# Инструкция для GIT
## Установка GIT

Заходим по ссылке скачиваем нужную вам версию и устанавливаем.

[GIT Download](https://gitforwindows.org/)

## Установка Visual Studio Code

[Visual Studio Code Download](https://code.visualstudio.com/)

### Создаем папку и проводим инициализацию при помощи команды _git init_

Ее необходимо ввести в корне вашего проекта. Это создаст в текущем каталоге новый подкаталог .git. В данной директории будет содержаться вся конфигурация Git и история проекта.

## Основные команды для работы с GIT
![](dfcc68df2d9384b1ad2c73e873f66af1.png)

* Добавить изменения в индекс(staging area) - git add (таким образом вы сообщаете Git какие именно изменения должны быть занесены в историю.)
* Закоммитить изменения - git commit (сохранить изменения в историю проекта)
* Запушить - git push (отправить результаты работы на удаленный сервер, чтобы другие разработчики тоже имели к ним доступ).

Итак, разберемся в этом подробнее. Проинициализировав Git репозиторий, вы начинаете вносить какие-то изменения в проект. Предположим, что вы создали файл `hello_world.txt` и работаете над его редактированием.

Введем _git status_ и увидим следующее:

    On branch master

    No commits yet

    Untr acked files:

        (use "git add <file>..." to include in what will be committed)

             hello_world.txt

Команда _git status_ отображает состояние директории и индекса(staging area). Это позволяет определить, какие файлы в проекте отслеживаются Git, а также какие изменения будут включены в следующий коммит.

Так как вы создали новый файл, Git определяет его как неотслеживаемый, и тут же подсказывает, что делать дальше:

    use “git add <file>...” to include in what will be committed

Так и поступим:

_git add hello_world.txt_
    
    On branch master
    No commits yet
    Changes to be commited:
	        (use "git rm --cached <file>..." to unstage)
    new file: hello_world.txt

Файл добавлен в индекс. Теперь можно закоммитить внесенные изменения и оставить небольшое описание. Делается это командой:

_git commit -m ‘first commit_

Готово! Мы сделали наш первый коммит! Далее добавим в наш файл строку “Hello, World!”, и снова проверим _git status_:

    On branch master 

    Changes not staged for commit:

        (use "git add <file>..." to update what will be committed)

        (use "git restore <file>..." to discard changes in working directory)

    no changes added to commit (use "git add" and/or "git commit -a")

Теперь Git сообщает, что у нас есть измененный файл hello_world.txt. И теперь нам сново нужно добавить его в индекс и затем закоммитить.

Далее необходимо добавить удаленный репозиторий в Git:

_git remote add <remote_name> <remote_repo_url>_

Эта команда сопоставит удаленное хранилище с ссылкой на локальный репозиторий. С этого момента можно обращаться к удаленному репозиторию через эту ссылку. Например:

_git remote add origin_ https://github.com/user/hello_world.git

В данном случае “origin” является коротким именем для удаленного репозитория, на которое он будет ссылаться. Вы можете выбрать совершенно любое имя - это не важно. “origin” это просто стандартное соглашение.

Осталось дело за малым - отправить результат нашей работы в репозиторий. Делается это следующим образом:

_git push origin_

Готово! Теперь история изменений вашего проекта будет храниться в удаленном репозитории.
## Работа с историей

![](ec040c5421ffc2e19d93ab68ec3825ee.png)

Итак, как записывать, сохранять и отправлять изменения в удаленное хранилище мы разобрались.

Настало время поговорить о том, как управлять историей проекта. А именно как просматривать изменения и как откатить проект до определенной точки.

Для инспектирования истории в Git предусмотрен определенный ряд команд, рассмотрим несколько из них:

 * git log

 * git show

 * git reflog

 * git reset
 
## 1. git log

Данная команда предназначена для отображения всей вашей истории. Она может быть весьма удобна, если вам понадобилось узнать, какие изменения вы вносили ранее. Или если вам нужно откатиться до определенного места в истории, либо если есть нужда её отредактировать.

Если ввести git log без каких либо параметров, выглядит это примерно так:

_git log_

    commit 957e1132f57d83§dbd402faf3c858cf5ba8b335f (HEAD -> master)

    Author: egor <egor@mail.ru>

    Date: Fri Jul 16 13:25:21 1021 +0300

        fourth commit 

    commit ekd53dkcld4dkf334r3r3sefio5dk6kfl54dkf53 

    Author: egor <egor@mail.ru>

    Date: Fri Jul 16 13:22:25 2021 +0300

        third commit

    commit dslf4453lk34jk34k3h5g34u6m5n75j7kj3l345k 

    Date: Fri Jul 16 13:22:27 2021 +0300

        second commit

    commit h4k4o5jk2lhkl234jkl6nkg6j4lh4gjbh6ll45k4

    Author: egor <egor@mail.ru>

    Date: Fri Jul 16 13:21:32 2021 +0300

        first commit

_git log_ имеет огромное множество дополнительных параметров, которые будут влиять на вывод в консоль. Вам предоставляется выбор на любой вкус.

Хотите просмотреть последние три коммита? Пожалуйста:

_git log -3_

    commit ekd53dkcld4dkf334r3r3sefio5dk6kfl54dkf53 

    Author: egor <egor@mail.ru>

    Date: Fri Jul 16 13:22:25 2021 +0300

        third commit

    commit dslf4453lk34jk34k3h5g34u6m5n75j7kj3l345k 

    Date: Fri Jul 16 13:22:27 2021 +0300

        second commit

    commit h4k4o5jk2lhkl234jkl6nkg6j4lh4gjbh6ll45k4

    Author: egor <egor@mail.ru>

    Date: Fri Jul 16 13:21:32 2021 +0300

     first commit
Есть необходимость вывести все в одну линию? Запросто:

_git log --oneline_

## 2. git show

Команда git show используется для отображения полной информации о любом объекте в Git, будь то коммит или ветка. По умолчанию _git show_ отображает информацию коммита, на который в данный момент времени указывает HEAD.

Для удобства работы git show оснащен рядом дополнительных параметров, некоторые из них мы рассмотрим ниже.

Итак, если ввести _git show_, мы получим следующий результат:

    commit 957e1132f57d83§dbd402faf3c858cf5ba8b335f (HEAD -> master)

    Author: egor <egor@mail.ru>

    Date: Fri Jul 16 13:25:21 1021 +0300

        fourth commit 

    diff --git a/hello_world.txt b/hello_world.txt

    index b402110..d49b5d7 10044

    --- a/hello_world.txt

    +++ b/hello_world.txt

    @@ -1,2 +1,3 @@

        Hello world!

        Bye, bye!

    +See you soon!

Здесь представлена полная информация о последнем коммите, а также какие именно изменения он в себя включает.

Мы также можем вывести диапазон из указанных коммитов. Диапазон указывается полуоткрытым интервалом, содержащим id коммитов, не включая первый элемент. Выглядит это следующим образом:

_git show 349de9d..957e113_

    commit 957e1132f57d83§dbd402faf3c858cf5ba8b335f (HEAD -> master)

    Author: egor <egor@mail.ru>

    Date: Fri Jul 16 13:25:21 1021 +0300

        fourth commit 

    diff --git a/hello_world.txt b/hello_world.txt

    index b402110..d49b5d7 10044

    --- a/hello_world.txt

    +++ b/hello_world.txt

    @ -1,2 +1,3 @@

     Hello world!

     Bye, bye!

    +See you soon!

    commit ekd53dkcld4dkf334r3r3sefio5dk6kfl54dkf53 

    Author: egor <egor@mail.ru>

    Date: Fri Jul 16 13:22:25 2021 +0300

     third commit

    diff --git a/hello_world.txt b/hello_world.txt

    index cd08755..b402110 100644

    --- a/hello_world.txt

    +++ b/hello_world.txt

    @@ -1 +1,2 @@

        Hello world!

    +Bye, bye!
Для более лаконичного вывода, можно воспользоваться командой:

_git show --oneline_

    957e113 (HEAD -> master) fourth commit

    diff --git a/hello_world.txt b/hello_world.txt

    index b402110..d49b5d7 10044

    --- a/hello_world.txt

    +++ b/hello_world.txt

    @@ -1,2 +1,3 @@

        Hello world!

        Bye, bye!

        +See you soon!

Таким образом, мы сократим id коммита, а также исключим авторство и дату коммита.

## 3. git reflog

Эта команда выводит упорядоченный список коммитов, на которые указывал HEAD. Грубо говоря, она отображает историю всех ваших перемещений по проекту.

Основное преимущество этой команды заключается в том, что если вы вдруг случайно удалили часть истории или откатились назад, вы сможете проинспектировать момент утраты нужной вам информации и откатиться обратно.

Это возможно за счет того, что _git reflog_ хранит свою информацию на вашей машине отдельно от коммитов, поэтому при удалении чего-либо в истории, в сможете это найти в _git reflog_.

Вывод этой команды выглядит следующим образом:

    957e113 (HEAD -> master) HEAD@{5}: commit: fourth commit

    ekd53dk HEAD@{6}: commit: third commt

    dslf445 HEAD@{7}: commit: second commit

    h4k4o5j HEAD@{8}: commit (intial): first commit 

## 4. git reset

![](5da2f213c5069f56d575682853cc1811.jpeg)

Теперь давайте рассмотрим очень полезную команду `git reset`. Она позволяет откатить проект до определенной точки.

Эту команду можно использовать с тремя параметрами:

* git reset --soft commit

* git reset --mixed commit

* git reset --hard commit

Рассмотрим их по порядку. Для этого сначала давайте вспомним, что такое index. Как я упоминал ранее, index - это временный файл, который фиксирует структуру Git проекта в определенный момент времени. Это важная деталь сейчас, поскольку команда git reset в зависимости от параметра прокидывает нас в истории проекта с соответствующими состояниями индекса.



1. В случае с --soft, содержимое вашего индекса, а также рабочей директории, остается неизменным. Это значит, что если мы откатимся назад на пару коммитов, мы изменим ссылку указателя HEAD на указанный коммит и все изменения, которые были до этого внесены, окажутся в индексе.

2. При использовании параметра --mixed, мы опять-таки изменим ссылку указателя HEAD, но все предыдущие изменения в индекс не попадут, а будут отслеживаться как не занесенные в индекс. Это дает возможность внести в индекс только те изменения, которые нам необходимы, что довольно удобно!

3. Если использовать команду git reset с параметром --hard, мы снова изменим ссылку указателя HEAD, но все предыдущие изменения не попадут ни в индекс, ни в зону отслеживаемых файлов. Это значит, что мы полностью сотрем все изменения, которые вносили ранее. Это также удобно, если вы знаете, что вам больше не пригодится ваша предыдущая работа над проектом.


Давайте вернемся к нашему репозиторию и рассмотрим следующий пример:

_git log --oneline_

    957e113 (HEAD -> master) fourth commit

    ekd53dk third commit

    dslf445 second commit

    h4k4o5j first commit
Итак, в ходе нашей работы, мы сделали четыре коммита. Предположим, что мы хотим откатить проект до второго коммита. Давайте посмотрим, как это будет происходить, используя разные параметры:

_git reset --soft 349de9d_

Далее, проверим индекс:

_git status_

    On branch master

    Changes to be committed:

        (use "git restore --staged <file>..." to unstage)

        modified: hello_world.txt
И снова _git log --oneline_:

    dslf445 (HEAD -> master) second commit

    h4k4o5j first commit
Как и ожидалось, указатель HEAD переместился на второй коммит, а состояние индекса осталось неизменным.

Теперь повторим наши действия, но уже с параметром --mixed:

_git reset --mixed 349de9d_

Проверим _git status-:

    On branch master

    Changes not staged for commit:

        (use "git add <file>..." to update what will be committed)

        (use "git restore <file>..." to discard changes in working directory)

            modified: hello_world.txt
А также _git log --oneline_:

    dslf445 (HEAD -> master) second commit

    h4k4o5j first commit
В данном случае, указатель снова переместился на второй коммит, но предыдущие изменения попали в зону отслеживаемых файлов. Это значит, что теперь мы можем решить - оставить эти изменения, добавив их в индекс, либо избавиться от них.

И в заключении повторим ту же последовательность действий с параметром --hard.

_git reset --hard 349de9d_

Снова проверяем _git status_:

    On branch master

    nothing to commit, working tree clean
И _git log --oneline_:

    dslf445 (HEAD -> master) second commit

    h4k4o5j first commit
Здесь указатель HEAD переместился на второй коммит, а все предыдущие изменения были стерты, что видно по пустому индексу и зоне отслеживаемых файлов.

И если посмотреть сейчас содержимое файла, то мы увидим единственную строку “Hello, world!”, которую мы с вами добавляли в файл во втором коммите.
***
## Ветвление в Git

Почти каждая система контроля версий имеет поддержку ветвления. Ветвление означает, что у вас есть возможность работать над разными версиями проекта. То есть, если раньше история вашей разработки являла собой прямую последовательность коммитов, то теперь она может расходиться в определенных точках.

Это очень полезная функция по многим причинам, например для взаимодействия нескольких разработчиков. Представьте, вы с коллегой корпите над одним проектом. Каждый из вас работает над разными фичами, и для того чтобы не мешать друг другу, вы можете работать в разных ветках, а по окончанию работы слить эти ветки в одну.

Давайте попробуем с этим поработать на нашем примере. У нас имеется следующая последовательность коммитов.

    957e113 (HEAD -> master) fourth commit

    ekd53dk third commit

    dslf445 second commit

    h4k4o5j first commit

Git по умолчанию во время инициализации создает ветку master и уже ведет свою работу в ней. Мы можем в этом убедиться введя команду:

_git branch_

* master
Предположим, что нам по какой-либо причине понадобилось создать новую ветку и вести работу в ней. Для этого сначала необходимо её создать.

Делается это при помощи команды git branch <branch_name>. Давайте создадим ветку “dev”:

_git branch dev_

Теперь введя команду git branch мы увидим следующее:

    dev

    * master
Звёздочкой Git указывает на текущую ветку, в которой мы работаем.

Для того чтобы переключиться на другую ветку используют команду git checkout <branch_name>. Давайте переключимся на ветку “dev”.

_git checkout dev_

Switched to branch 'dev'
Теперь внесем любые изменения в файл hello_world.txt и сделаем коммит, после чего посмотрим, как выглядят наши ветки после редактирования.

Взглянем на _git log --oneline_:

    dece9c9 (HEAD -> dev) fifth commit

    957e113 (master) fourth commit

    ekd53dk third commit

    dslf445 second commit

    h4k4o5j first commit
Как и следовало ожидать, в нашей истории появился еще один - пятый коммит.

Теперь перейдем на ветку master

_git checkout master_

И просмотрим _git log --oneline_, и убедимся в том что все осталось без изменений.

    957e113 (HEAD -> master) fourth commit

    ekd53dk third commit

    dslf445 second commit

    h4k4o5j first commit

Помимо разделения истории в Git мы также можем соединять воедино два потока разработки. Это значит, что нашу проделанную работу в новой ветке мы можем слить обратно в master. Такой процесс слияния можно выполнить при помощи команды git merge <branch_name>. То есть, если мы хотим слить изменения из ветки “dev” в ветку “master”, нам необходимо перейти на ветку “master” и в ней выполнить:

_git merge dev_

    Updating 957e113..dece9c9

    Fast-forward

        hello_world.txt | 1 +

        1 file chaged, 1 insertion(+)
Теперь если мы проверим _git log --oneline_, то убедимся в том, что новый коммит из ветки “dev” переместился в ветку “master”.

    dece9c9 (HEAD -> master, dev) fifth commit

    957e113 fourth commit

    ekd53dk third commit

    dslf445 second commit

    h4k4o5j first commit
Теперь от ненужной ветки можно избавиться и удалить её с помощью команды _git branch -d <branch_name>_.

В данных примерах я не учитывал того факта, что при слиянии веток иногда возможно возникновение конфликтов, которые приходится разрешать вручную. Как правило это происходит при слиянии двух веток, в которых одновременно велась какая-то работа. Или же когда в новой ветке вы задели изменения старой. Я не буду рассматривать такие примеры, т.к. разрешение конфликтов - тема не маленькая, и многие вещи в ней можно разобрать самостоятельно в ходе практики.
***
## Заключение

Мы рассмотрели самые основные приемы работы с Git. Моей задачей было сформировать в вас некоторое понимание - что есть система контроля версий и познакомить с одной из них. Мы разобрали структуру Git проекта, и теперь у вас есть представление о том, как он работает. Мы познакомились с самыми важными командами в Git, рассмотрели некоторые команды для инспектирования истории проекта и даже овладели несколькими приемами для перемещения HEAD указателя. Мы немного затронули тему ветвления, попробовали создать свою новую ветку и слить её с базовой.

![](end-over-finished-typewriter-ss-1920.jpg)



